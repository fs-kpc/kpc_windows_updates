#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2023 K&P Computer Service- und Vertriebs-GmbH - License: GNU General Public License v2
################################################################################################################
#
# Author: K&P Computer Service- und Vertriebs-GmbH
# Author: Matthias Binder
# License: GNU General Public License
# Date: 05/2023
#
# 
# For Support and Sales Please Contact K&P Computer!
#
# E-Mail: hds@kpc.de
#
# 24/7 Helpdesk-Support:
# International: +800 4479 3300
# Germany: +49 6122 7071 330
# Austria: +43 1 525 1833
#
# Web Germany: https://www.kpc.de
# Web Austria: https://www.kpc.at
# Web International: https://www.kpc.de/en
#
################################################################################################################



#<<<windows_lastupdateinstalldate_kpc:sep(9):cached(1688714200,3600)>>>
#1688584264 07/05/2023 19:11:04 Security Intelligence Update for Microsoft Defender Antivirus - KB2267602 (Version 1.391.3675.0)XXXNEWLINEXXX07/04/2023 19:11:08 Security Intelligence Update for Microsoft Defender Antivirus - KB2267602 (Version 1.391.3559.0)XXXNEWLINEXXX07/03/2023 19:02:09 Security Intelligence Update for Microsoft Defender Antivirus - KB2267602 (Version 1.391.3451.0)XXXNEWLINEXXX07/03/2023 18:32:29 2023-06 Cumulative Update for Microsoft server operating system version 21H2 for x64-based Systems (KB5027225)XXXNEWLINEXXX07/03/2023 18:12:22 2023-06 Cumulative Update for Microsoft server operating system version 21H2 for x64-based Systems (KB5027225)XXXNEWLINEXXX07/03/2023 18:10:46 2023-06 Cumulative Update for .NET Framework 3.5, 4.8 and 4.8.1 for Microsoft server operating system version 21H2 for x64 (KB5027544)XXXNEWLINEXXX07/03/2023 18:10:18 Security Intelligence Update for Microsoft Defender Antivirus - KB2267602 (Version 1.391.3440.0)XXXNEWLINEXXX07/03/2023 18:10:09 2022-08 Security Update for Microsoft server operating system version 21H2 for x64-based Systems (KB5012170)XXXNEWLINEXXX07/03/2023 18:09:43 XXXNEWLINEXXX


support = "For Support and Sales Please Contact K&P Computer! \n \n E-Mail: hds@kpc.de \n \n 24/7 Helpdesk-Support: \n International: +800 4479 3300 \n Germany: +49 6122 7071 330 \n Austria: +43 1 525 1833 \n\n Web Germany: https://www.kpc.de \n Web Austria: https://www.kpc.at \n Web International: https://www.kpc.de/en"

import argparse
import requests
import psutil
import json
from datetime import datetime
import time
import re
import glob
import sys

import json
import sys, os, getopt, re, subprocess

import os
import os.path


def inventory_windows_lastupdateinstalldate_kpc(info):
    return [(x[0], None) for x in info]


#Linux Homepath of OMD User
homepath = os.path.expanduser('~')


def check_windows_lastupdateinstalldate_kpc(item, _no_params, info):

    for line in info:
        if len(line) < 8:
            continue  # Skip incomplete lines

        job_name, job_type, job_last_state, job_last_result, job_failed_backup_info, job_creation_time, job_end_time, computername = line[
            :8
        ]

        #This is the Folder Config Part, where CheckMK should store all Files
        path = homepath + "/kpcchecks/veeam_jobs_kpc/" + str(computername) + "/"

        #Create Folder if not Exits
        if not os.path.exists(path):
             os.makedirs(path)
        

        #Full Path of the State File:
        statefilefullpath = path + job_name + ".json"

        #We create Json Files with the last States if the Job is not running. We will use the Values if the Job is Running, to Show the Last Finished state in CheckMK
        if job_last_state not in ["Working", "Postprocessing"]:

             fileoutput = {
                 "job_name": job_name,
                 "job_type": job_type,
                 "job_last_state": job_last_state,
                 "job_last_result": job_last_result,
                 "job_failed_backup_info": job_failed_backup_info,
                 "job_creation_time": job_creation_time,
                 "job_end_time": job_end_time,
                 "computername": computername
             }
        
             #Write Results into Json File for Each Service, so we can track last "OK" State with the Timestamp. If the CRC Counter goes up, we know, that we have to do an CRIT Error Message
             json_object = json.dumps(fileoutput, indent=4)
             statefile = open(statefilefullpath, "w")
             statefile.write(json_object)
             statefile.close()


        
        #Load Last Backup State if available
        file_exists = os.path.exists(statefilefullpath)
        if file_exists is True:
             with open(statefilefullpath) as json_file:
                  laststate = json.load(json_file)
             laststate['job_failed_backup_info'] = laststate['job_failed_backup_info'].replace("XXXNEWLINEXXX", "\n")
             laststate['job_failed_backup_info'] = "\n" + laststate['job_failed_backup_info'] + "\n \n \n" + support


        job_failed_backup_info = job_failed_backup_info.replace("XXXNEWLINEXXX", "\n")
        job_failed_backup_info = "\n" + job_failed_backup_info + "\n \n \n" + support
        if job_name != item:
            continue  # Skip not matching lines

        #If there is no last state available when a job is running use this
        if job_last_state in ["Working", "Postprocessing"] and file_exists is False:
            return 0, "Running since %s (current state is: %s)" % (
                job_creation_time,
                job_last_state,
            )
        #if there is a last state available when a job is running use this
        if job_last_state in ["Working", "Postprocessing"] and laststate: 
             if laststate['job_last_result'] == "Success":
                 state = 0
             elif laststate['job_last_state'] == "Idle" and laststate['job_type'] == "BackupSync":
                # A sync job is always idle
                 state = 0
             elif laststate['job_last_result'] == "Failed":
                 state = 2
             elif laststate['job_last_state'] == "Stopped" and laststate['job_last_result'] == "Warning":
                 state = 1
             else:
                 state = 3

             return state, "Running since %s (current state is: %s) \n \n Last State: %s, Last Result: %s, Creation time: %s, End time: %s, Type: %s %s" % (
                 job_creation_time,
                 job_last_state,
                 laststate['job_last_state'],
                 laststate['job_last_result'],
                 laststate['job_creation_time'],
                 laststate['job_end_time'],
                 laststate['job_type'],
                 laststate['job_failed_backup_info'],
             )



       

        if job_last_result == "Success":
            state = 0
        elif job_last_state == "Idle" and job_type == "BackupSync":
            # A sync job is always idle
            state = 0
        elif job_last_result == "Failed":
            state = 2
        elif job_last_state == "Stopped" and job_last_result == "Warning":
            state = 1
        else:
            state = 3

        return state, "State: %s, Result: %s, Creation time: %s, End time: %s, Type: %s %s" % (
            job_last_state,
            job_last_result,
            job_creation_time,
            job_end_time,
            job_type,
            job_failed_backup_info,
        )


check_info["windows_lastupdateinstalldate_kpc"] = {
    "check_function": check_windows_lastupdateinstalldate_kpc,
    "inventory_function": inventory_windows_lastupdateinstalldate_kpc,
    "service_description": "Windows Update History KPC",
}
